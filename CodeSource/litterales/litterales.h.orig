#ifndef LITTERALES_H
#define LITTERALES_H
/*!
 * \file litterales.h
 * \brief Implementation des litterales
 * \author Blanquet - Martinache
 * \version 0.1
 */

#ifndef LITTERALES_H
#define LITTERALES_H

#include <iostream>
#include <string>


<<<<<<< Updated upstream




/*----------------------Classes mères-------------------------*/


class Operande {
=======
/*!
 * \class Opérande
 * \brief Regroupe l'ensemble des littérales et des opérateurs
*/
class Operande
{
>>>>>>> Stashed changes

}; //Utilité à vérifier

<<<<<<< Updated upstream
=======
/*!
 * \class Operateur
*/
class Operateur : public Operande
{
>>>>>>> Stashed changes

/*!
 * \class Litterale
*/

/*!
 * \class Litterale
*/
class Litterale : public Operande
{
public:
    virtual void afficher(std::ostream& f=std::cout) const=0;
};

<<<<<<< Updated upstream

class Programme : public Litterale {
=======
/*!
 * \class Programme
*/
class Programme : public Litterale
{
>>>>>>> Stashed changes
private:

public:

};

/*!
 * \class ExpressionPart
 */
class ExpressionPart : public Litterale
{

};

/*!
 * \class Expression
*/
class Expression : public Litterale
{
private:

};

/*!
 * \class LitteraleNumerique
*/
<<<<<<< Updated upstream
class LitteraleNumerique : public ExpressionPart {
=======
class LitteraleNumerique : public ExpressionPart
{
>>>>>>> Stashed changes

};

/*!
 * \class Atome
 */
class Atome : public ExpressionPart
{
private:
    std::string tab;
public:
<<<<<<< Updated upstream
    Atome(char* text): tab(text) {}
    char* getAtome() const {return tab;}




};






/*----------------------Classes de littérales numériques-------------------------*/



=======
    Atome(std::string text): tab(text) {}
    std::string getAtome() const {return tab;}
};

>>>>>>> Stashed changes
/*!
 * \class Entier
 */
class Entier : public LitteraleNumerique
{
private:
    int nb;
public:
    Entier():nb(0){}
    Entier(int n): nb(n) {}
    Entier& operator=(Entier a);
    Entier NEG() {if (nb>0) nb=-nb; return *this;}
    int getNb() const {return nb;}
    void setValue(int i) {nb=i;}
    void afficher(std::ostream& f) const {f<<nb;}

    /*----------Opérateurs-------------*/

    Litterale& operator+(Litterale& e);
    Entier& operator-(Entier& e) {nb-=e.getNb(); return *this;}
    Entier& operator*(Entier& e) {nb*=e.getNb(); return *this;}



};


/*!
 * \class Rationnel
 */
class Rationnel : public LitteraleNumerique
{
private:
	Entier numerateur;
	Entier denominateur;
public:
<<<<<<< Updated upstream
    Entier simplification();
    Rationnel(int e1, int e2);
=======
    // Constructeur (Avec conversion implicite de int e1,e2 en Entier
    Rationnel(int e1, int e2): numerateur(e1), denominateur(e2) {}
>>>>>>> Stashed changes
	int getNum() const {return numerateur.getNb();}
	int getDenom() const {return denominateur.getNb();}
    void setNum(int e) {numerateur=e;}
    void setDenom(int e) {denominateur=e;}
    double getNb() const {return numerateur.getNb()/denominateur.getNb();} //Utilité à démontrer
    void afficher(std::ostream& f) const {f<<getNum()<<"/"<<getDenom();}
};

/*!
 * \class Reel
 */
class Reel : public LitteraleNumerique
{
private:
    Entier entiere;
    Entier mantisse;
public:
    // Constructeur. Il faut utiliser des references sinon Reel va appeler le constructeur par defaut de Entier qui n'existe pas !
    Reel(Entier e1, Entier e2):entiere(e1),mantisse(e2){/*if(e2.getNb()<0) throw LitteraleException("Mantisse negative.");*/}
    Reel NEG() {if (entiere.getNb()>0) entiere=entiere.NEG(); return *this;}
    double getNb() const;
<<<<<<< Updated upstream
    int getEntiere() const {return entiere.getNb();}
    int getMantisse() const {return mantisse.getNb();}
    void setEntiere(int e) {entiere=e;}
    void setMantisse(int e) {mantisse=e;}
    void afficher(std::ostream& f) const {f<<getNb();}
=======
    int getEntiere() const {return entiere.getNb();} //Utilité à démontrer
    int getMantisse() const {return mantisse.getNb();} //Utilité à démontrer
    void afficher(std::ostream& f=std::cout) const {f<<getNb();}
>>>>>>> Stashed changes

};

/*!
 * \class Complexe
 */
class Complexe : public ExpressionPart
{
private:
    LitteraleNumerique* realPart; //On ne connait pas le type exact. C'est soit un reel, soit un rationnel, soit un entier.
    LitteraleNumerique* imagPart;
public:
    Complexe(LitteraleNumerique& real, LitteraleNumerique& imag): realPart(&real), imagPart(&imag) {}
    LitteraleNumerique* getReal() const {return realPart;}
    LitteraleNumerique* getImag() const {return imagPart;}
    void setReal(LitteraleNumerique& lit) {realPart=&lit;}
    void setImag(LitteraleNumerique& lit) {imagPart=&lit;}
    void afficher(std::ostream& f) const {getReal()->afficher(f); f<<"$"; getImag()->afficher(f);} // A vérif
};


<<<<<<< Updated upstream

=======
>>>>>>> Stashed changes
#endif
